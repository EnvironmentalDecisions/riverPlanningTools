#' @title Create the boundary file to the conservation management plannning software
#'
#' @description Return a data.frame
#' generated by information about the boudary data from river data.
#'
#' @param file Object of class [data.frame()] or [SpatialLinesDataFrame()] or [SpatialPolygonsDataFrame()] that specifies
#' the relation between planning (river PU's). This file must contain the following fields:
#' \describe{
#'    \item{`GridID`}{`integer` unique identifier for each planning unit.}
#'    \item{`NextDownID`}{`integer` unique identifier for the planning unit immediately below. Set -1
#'    there isn't one below.}
#'    \item{`Length`}{`numeric` value of distance between the `GridID` and `NextDownID`.}
#'    }
#' @param distance_limit distance limit to stop to building the relation between units.
#' @param connection_limit number of connections limit to stop to building the relation between units.
#' @param export_csv is TRUE to export a .csv file with boundary connections.
#' @return A [data.frame()].
#' @examples
#' \donttest{
#' boundaryBuilder(file, distance_limit = 100, connection_limit = 20, export_csv = FALSE)
#' }
#'
#' @rdname boundaryBuilder
#' @export
#' @import methods utils

boundaryBuilder <- function(file, distance_limit = .Machine$integer.max,
                                  connection_limit = .Machine$integer.max,
                                  export_csv = FALSE){

  #checking if the input is a shapefile
  if(methods::is(file, "SpatialLinesDataFrame") || is(file, "SpatialPolygonsDataFrame")){
    df = ggplot2::fortify(file@data)

    #checking if the variables exists
    var = c("GridID","NextDownID","Length")
    if(!all(var %in% colnames(df))){
      var_needed <- which(!var %in% colnames(df))
      stop(paste("The following variables are needed: ", var[var_needed]),call. = FALSE)
    }

    #changing hydros values by grids values
    #if(df$GridID[1] != df$HydroID[1])
    #{
    #  df <- df[order(df$GridID),]
    #  df$NextDownID <- match(df$NextDownID,df$HydroID)
    #  df$NextDownID[is.na(df$NextDownID)] <- -1
    #  df <- df[,var]
    #}
    df <- df[,var]
  }
  else if(is.data.frame(file)){
    df = file
  }
  else{
    stop("Incompatible file (SpatialLinesDataFrame or DataFrame required)", call. = FALSE)
  }

  #creating empty data frame to distances
  length_df <- length(df$GridID)
  data_distances <- data.frame(id=integer(0),
                             down=integer(0),
                             distance=double(0))

  row_distances_data = 1
  for(i in 1:length_df)
  {
    #internal parameters
    row_df = i
    count_distance = 0
    n_connections = 0

    while(df$NextDownID[row_df] != -1)
    {
      #stop by number of connections
      if(n_connections == connection_limit || count_distance + df[row_df,3] >= distance_limit){
        break
      }

      #adding next down cell to distances data frame
      data_distances[row_distances_data,] <- list(df$GridID[i], df$NextDownID[row_df], count_distance + df[row_df,3])

      count_distance <- count_distance + df[row_df,3]
      row_df <- which(df$GridID==df$NextDownID[row_df])[1]


      row_distances_data = row_distances_data + 1
      n_connections = n_connections + 1

    }
    #adding last connection
    if(df$NextDownID[row_df] == -1 && n_connections != connection_limit){
      data_distances[row_distances_data,] <- list(df$GridID[i], df$NextDownID[row_df], count_distance + df[row_df,3])

      row_distances_data = row_distances_data + 1
    }
  }
  rownames(data_distances) <- c(1:nrow(data_distances))

  if(export_csv == FALSE){
    return(data_distances)
  }
  else{
    utils::write.csv(data_distances, file="Longitudinal_distance.csv", row.names = FALSE)
  }
}

#How to use---------------------------------------------------------
#From .csv
#The .csv file must contain the following variables: GridID, NextDownID, Length

##Name_data_csv  = "Douro2.csv"
##file = read.csv(Name_data_csv)

#From shapefile data
#The shapefile must contain the following variables: GridID, HydroID, NextDownID, Length
##Name_data_shp = "River_500_Albers.shp"
##file = readOGR(Name_data_shp)

#Function
#distance = maximum distance allowed between units
#connection_limit = maximum connections allowed between units
##Create_longitudinal_distances(file)
